<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>JR SFML Chess Game: Jr::ChessLogic Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">JR SFML Chess Game
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classJr_1_1ChessLogic.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classJr_1_1ChessLogic-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Jr::ChessLogic Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Gestion complète de la logique d'un jeu d'échecs.  
 <a href="classJr_1_1ChessLogic.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ChessLogic_8hpp_source.html">ChessLogic.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a253c319b5992443766b63fb62bea6abb" id="r_a253c319b5992443766b63fb62bea6abb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structJr_1_1Piece.html">Piece</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classJr_1_1ChessLogic.html#a253c319b5992443766b63fb62bea6abb">getPieceAtSquare</a> (int square) const</td></tr>
<tr class="memdesc:a253c319b5992443766b63fb62bea6abb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtient la pièce située à une case donnée.  <br /></td></tr>
<tr class="separator:a253c319b5992443766b63fb62bea6abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa88200f0181256b91dd30b640a059e2d" id="r_aa88200f0181256b91dd30b640a059e2d"><td class="memItemLeft" align="right" valign="top"><a id="aa88200f0181256b91dd30b640a059e2d" name="aa88200f0181256b91dd30b640a059e2d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ChessLogic</b> ()</td></tr>
<tr class="memdesc:aa88200f0181256b91dd30b640a059e2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructeur par défaut. Initialise l'état interne pour une partie fraîche. <br /></td></tr>
<tr class="separator:aa88200f0181256b91dd30b640a059e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a424e4a7e07f392783456305bfe833052" id="r_a424e4a7e07f392783456305bfe833052"><td class="memItemLeft" align="right" valign="top"><a id="a424e4a7e07f392783456305bfe833052" name="a424e4a7e07f392783456305bfe833052"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>initializeBoard</b> ()</td></tr>
<tr class="memdesc:a424e4a7e07f392783456305bfe833052"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise la position de départ du plateau (placement initial des pièces). Réinitialise aussi toutes les variables d'état (roque, promotion, etc). <br /></td></tr>
<tr class="separator:a424e4a7e07f392783456305bfe833052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b8e42452b85679c562632d278dcfe9" id="r_a43b8e42452b85679c562632d278dcfe9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classJr_1_1ChessLogic.html#a43b8e42452b85679c562632d278dcfe9">isValidMove</a> (int from, int to) const</td></tr>
<tr class="memdesc:a43b8e42452b85679c562632d278dcfe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vérifie si un mouvement est valide selon les règles du jeu.  <br /></td></tr>
<tr class="separator:a43b8e42452b85679c562632d278dcfe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5845e6976c588fbc888a02c7d0196076" id="r_a5845e6976c588fbc888a02c7d0196076"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classJr_1_1ChessLogic.html#a5845e6976c588fbc888a02c7d0196076">makeMove</a> (int from, int to)</td></tr>
<tr class="memdesc:a5845e6976c588fbc888a02c7d0196076"><td class="mdescLeft">&#160;</td><td class="mdescRight">Effectue un coup valide et met à jour l'état du jeu.  <br /></td></tr>
<tr class="separator:a5845e6976c588fbc888a02c7d0196076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae69b8bdbe7e4dadf7610533a8c8dd45c" id="r_ae69b8bdbe7e4dadf7610533a8c8dd45c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classJr_1_1ChessLogic.html#ae69b8bdbe7e4dadf7610533a8c8dd45c">getLegalMoves</a> (int from) const</td></tr>
<tr class="memdesc:ae69b8bdbe7e4dadf7610533a8c8dd45c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne la liste des coups légaux pour la pièce située à la case donnée.  <br /></td></tr>
<tr class="separator:ae69b8bdbe7e4dadf7610533a8c8dd45c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab91c428d04308450340957bf716c8df7" id="r_ab91c428d04308450340957bf716c8df7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classJr_1_1ChessLogic.html#ab91c428d04308450340957bf716c8df7">isKingInCheck</a> (bool whiteKing) const</td></tr>
<tr class="memdesc:ab91c428d04308450340957bf716c8df7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indique si le roi de la couleur spécifiée est en échec.  <br /></td></tr>
<tr class="separator:ab91c428d04308450340957bf716c8df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b57939b3aad263be45a3d3ce2d77867" id="r_a5b57939b3aad263be45a3d3ce2d77867"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classJr_1_1ChessLogic.html#a5b57939b3aad263be45a3d3ce2d77867">wouldBeInCheck</a> (int from, int to, bool whiteKing) const</td></tr>
<tr class="memdesc:a5b57939b3aad263be45a3d3ce2d77867"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vérifie si un coup hypothétique mettrait le roi en échec.  <br /></td></tr>
<tr class="separator:a5b57939b3aad263be45a3d3ce2d77867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e13a0213ea6fab80ebbb636bf05e9ff" id="r_a7e13a0213ea6fab80ebbb636bf05e9ff"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classJr_1_1ChessLogic.html#a7e13a0213ea6fab80ebbb636bf05e9ff">getWhiteTurn</a> () const</td></tr>
<tr class="memdesc:a7e13a0213ea6fab80ebbb636bf05e9ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtient le tour actuel.  <br /></td></tr>
<tr class="separator:a7e13a0213ea6fab80ebbb636bf05e9ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80417575ab23dd5d822beb75694f5ddc" id="r_a80417575ab23dd5d822beb75694f5ddc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classJr_1_1ChessLogic.html#a80417575ab23dd5d822beb75694f5ddc">isPromotionPending</a> () const</td></tr>
<tr class="memdesc:a80417575ab23dd5d822beb75694f5ddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indique si une promotion est en attente de choix.  <br /></td></tr>
<tr class="separator:a80417575ab23dd5d822beb75694f5ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ba8ced0444457ad1871a9bdfedf965a" id="r_a6ba8ced0444457ad1871a9bdfedf965a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classJr_1_1ChessLogic.html#a6ba8ced0444457ad1871a9bdfedf965a">getPromotionWhite</a> () const</td></tr>
<tr class="memdesc:a6ba8ced0444457ad1871a9bdfedf965a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indique la couleur du pion en promotion.  <br /></td></tr>
<tr class="separator:a6ba8ced0444457ad1871a9bdfedf965a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3300ac22961352cf51c4c05f539a01dd" id="r_a3300ac22961352cf51c4c05f539a01dd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classJr_1_1ChessLogic.html#a3300ac22961352cf51c4c05f539a01dd">getPromotionSquare</a> () const</td></tr>
<tr class="memdesc:a3300ac22961352cf51c4c05f539a01dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne la case où la promotion doit être effectuée.  <br /></td></tr>
<tr class="separator:a3300ac22961352cf51c4c05f539a01dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15e4171c8645f7da53310f807723014" id="r_ab15e4171c8645f7da53310f807723014"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classJr_1_1ChessLogic.html#ab15e4171c8645f7da53310f807723014">promotePawn</a> (int square, PieceType newType)</td></tr>
<tr class="memdesc:ab15e4171c8645f7da53310f807723014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Effectue la promotion d'un pion à une case donnée vers un nouveau type de pièce.  <br /></td></tr>
<tr class="separator:ab15e4171c8645f7da53310f807723014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10c6ebea5a9efe93a887fcfc31dc7650" id="r_a10c6ebea5a9efe93a887fcfc31dc7650"><td class="memItemLeft" align="right" valign="top">std::map&lt; int, <a class="el" href="structJr_1_1Piece.html">Piece</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classJr_1_1ChessLogic.html#a10c6ebea5a9efe93a887fcfc31dc7650">getCurrentBoardState</a> () const</td></tr>
<tr class="memdesc:a10c6ebea5a9efe93a887fcfc31dc7650"><td class="mdescLeft">&#160;</td><td class="mdescRight">Récupère l'état complet du plateau sous forme de map case -&gt; pièce.  <br /></td></tr>
<tr class="separator:a10c6ebea5a9efe93a887fcfc31dc7650"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a174fc9bcebb4078dea570be8ffd8dbb7" id="r_a174fc9bcebb4078dea570be8ffd8dbb7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classJr_1_1ChessLogic.html#a174fc9bcebb4078dea570be8ffd8dbb7">isEmpty</a> (int sq) const</td></tr>
<tr class="memdesc:a174fc9bcebb4078dea570be8ffd8dbb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vérifie si la case spécifiée est vide.  <br /></td></tr>
<tr class="separator:a174fc9bcebb4078dea570be8ffd8dbb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6896304132806f888290d52dcd3048bd" id="r_a6896304132806f888290d52dcd3048bd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classJr_1_1ChessLogic.html#a6896304132806f888290d52dcd3048bd">isEnemy</a> (int sq, bool whitePiece) const</td></tr>
<tr class="memdesc:a6896304132806f888290d52dcd3048bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vérifie si la pièce à la case donnée est ennemie par rapport à la couleur spécifiée.  <br /></td></tr>
<tr class="separator:a6896304132806f888290d52dcd3048bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7c5db1773724ef1ea7529daefbb71fb" id="r_aa7c5db1773724ef1ea7529daefbb71fb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classJr_1_1ChessLogic.html#aa7c5db1773724ef1ea7529daefbb71fb">getRawMoves</a> (const <a class="el" href="structJr_1_1Piece.html">Piece</a> &amp;piece, int from) const</td></tr>
<tr class="memdesc:aa7c5db1773724ef1ea7529daefbb71fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Génère les déplacements "bruts" possibles pour une pièce à une case donnée.  <br /></td></tr>
<tr class="separator:aa7c5db1773724ef1ea7529daefbb71fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:af8aefeb9fca02b3ff5b8e9d80290f3bc" id="r_af8aefeb9fca02b3ff5b8e9d80290f3bc"><td class="memItemLeft" align="right" valign="top"><a id="af8aefeb9fca02b3ff5b8e9d80290f3bc" name="af8aefeb9fca02b3ff5b8e9d80290f3bc"></a>
std::map&lt; std::string, uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>bitboards</b></td></tr>
<tr class="memdesc:af8aefeb9fca02b3ff5b8e9d80290f3bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitboards représentant la position de chaque type de pièce, identifiées par une chaîne (ex: "wP" pour pions blancs) <br /></td></tr>
<tr class="separator:af8aefeb9fca02b3ff5b8e9d80290f3bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bba0589ab6ff1f114574efea823987c" id="r_a8bba0589ab6ff1f114574efea823987c"><td class="memItemLeft" align="right" valign="top"><a id="a8bba0589ab6ff1f114574efea823987c" name="a8bba0589ab6ff1f114574efea823987c"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>bitboardPieces</b></td></tr>
<tr class="memdesc:a8bba0589ab6ff1f114574efea823987c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitboard représentant toutes les cases occupées par une pièce (blanche ou noire) <br /></td></tr>
<tr class="separator:a8bba0589ab6ff1f114574efea823987c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a350db9fdba71b42b7a2130c6a0af4f15" id="r_a350db9fdba71b42b7a2130c6a0af4f15"><td class="memItemLeft" align="right" valign="top"><a id="a350db9fdba71b42b7a2130c6a0af4f15" name="a350db9fdba71b42b7a2130c6a0af4f15"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>whiteTurn</b> = true</td></tr>
<tr class="memdesc:a350db9fdba71b42b7a2130c6a0af4f15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indique si c'est au tour des blancs de jouer (true) ou des noirs (false) <br /></td></tr>
<tr class="separator:a350db9fdba71b42b7a2130c6a0af4f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af864c0ba865802ae46c4745b2ba38864" id="r_af864c0ba865802ae46c4745b2ba38864"><td class="memItemLeft" align="right" valign="top"><a id="af864c0ba865802ae46c4745b2ba38864" name="af864c0ba865802ae46c4745b2ba38864"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>enPassantSquare</b> = -1</td></tr>
<tr class="memdesc:af864c0ba865802ae46c4745b2ba38864"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index de la case cible d'une prise en passant possible, ou -1 si aucune. <br /></td></tr>
<tr class="separator:af864c0ba865802ae46c4745b2ba38864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10029e34006ec074a14e832dea28a850" id="r_a10029e34006ec074a14e832dea28a850"><td class="memItemLeft" align="right" valign="top"><a id="a10029e34006ec074a14e832dea28a850" name="a10029e34006ec074a14e832dea28a850"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>whiteKingMoved</b> = false</td></tr>
<tr class="memdesc:a10029e34006ec074a14e832dea28a850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indique si le roi blanc a déjà bougé (affecte la possibilité de roque) <br /></td></tr>
<tr class="separator:a10029e34006ec074a14e832dea28a850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eea1b97becdece30c39aa3437f1d348" id="r_a5eea1b97becdece30c39aa3437f1d348"><td class="memItemLeft" align="right" valign="top"><a id="a5eea1b97becdece30c39aa3437f1d348" name="a5eea1b97becdece30c39aa3437f1d348"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>whiteRookKingsideMoved</b> = false</td></tr>
<tr class="memdesc:a5eea1b97becdece30c39aa3437f1d348"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indique si la tour blanche côté roi a déjà bougé <br /></td></tr>
<tr class="separator:a5eea1b97becdece30c39aa3437f1d348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2183d25bd688aecf98285d03df5e18c2" id="r_a2183d25bd688aecf98285d03df5e18c2"><td class="memItemLeft" align="right" valign="top"><a id="a2183d25bd688aecf98285d03df5e18c2" name="a2183d25bd688aecf98285d03df5e18c2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>whiteRookQueensideMoved</b> = false</td></tr>
<tr class="memdesc:a2183d25bd688aecf98285d03df5e18c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indique si la tour blanche côté dame a déjà bougé <br /></td></tr>
<tr class="separator:a2183d25bd688aecf98285d03df5e18c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cfa167d2093c5cdf3aed759c1db1f7a" id="r_a3cfa167d2093c5cdf3aed759c1db1f7a"><td class="memItemLeft" align="right" valign="top"><a id="a3cfa167d2093c5cdf3aed759c1db1f7a" name="a3cfa167d2093c5cdf3aed759c1db1f7a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>blackKingMoved</b> = false</td></tr>
<tr class="memdesc:a3cfa167d2093c5cdf3aed759c1db1f7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indique si le roi noir a déjà bougé <br /></td></tr>
<tr class="separator:a3cfa167d2093c5cdf3aed759c1db1f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a696b35251f237859a68c842d0e039dc2" id="r_a696b35251f237859a68c842d0e039dc2"><td class="memItemLeft" align="right" valign="top"><a id="a696b35251f237859a68c842d0e039dc2" name="a696b35251f237859a68c842d0e039dc2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>blackRookKingsideMoved</b> = false</td></tr>
<tr class="memdesc:a696b35251f237859a68c842d0e039dc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indique si la tour noire côté roi a déjà bougé <br /></td></tr>
<tr class="separator:a696b35251f237859a68c842d0e039dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f03032d03c8193b446ebf9c59e65945" id="r_a0f03032d03c8193b446ebf9c59e65945"><td class="memItemLeft" align="right" valign="top"><a id="a0f03032d03c8193b446ebf9c59e65945" name="a0f03032d03c8193b446ebf9c59e65945"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>blackRookQueensideMoved</b> = false</td></tr>
<tr class="memdesc:a0f03032d03c8193b446ebf9c59e65945"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indique si la tour noire côté dame a déjà bougé <br /></td></tr>
<tr class="separator:a0f03032d03c8193b446ebf9c59e65945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c0d618f23332050c01363f69e3f56f" id="r_af4c0d618f23332050c01363f69e3f56f"><td class="memItemLeft" align="right" valign="top"><a id="af4c0d618f23332050c01363f69e3f56f" name="af4c0d618f23332050c01363f69e3f56f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>promotionPending</b> = false</td></tr>
<tr class="memdesc:af4c0d618f23332050c01363f69e3f56f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indique si une promotion de pion est en attente. <br /></td></tr>
<tr class="separator:af4c0d618f23332050c01363f69e3f56f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87e877526a56eebed35c206b4f711df3" id="r_a87e877526a56eebed35c206b4f711df3"><td class="memItemLeft" align="right" valign="top"><a id="a87e877526a56eebed35c206b4f711df3" name="a87e877526a56eebed35c206b4f711df3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>promotionWhite</b> = true</td></tr>
<tr class="memdesc:a87e877526a56eebed35c206b4f711df3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indique si la promotion concerne un pion blanc (true) ou noir (false) <br /></td></tr>
<tr class="separator:a87e877526a56eebed35c206b4f711df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57c4bec58b26aaed18110c963c280d88" id="r_a57c4bec58b26aaed18110c963c280d88"><td class="memItemLeft" align="right" valign="top"><a id="a57c4bec58b26aaed18110c963c280d88" name="a57c4bec58b26aaed18110c963c280d88"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>promotionSquare</b> = -1</td></tr>
<tr class="memdesc:a57c4bec58b26aaed18110c963c280d88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Case où la promotion doit avoir lieu (index), -1 si aucune promotion en attente. <br /></td></tr>
<tr class="separator:a57c4bec58b26aaed18110c963c280d88"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Gestion complète de la logique d'un jeu d'échecs. </p>
<p>Cette classe maintient l'état interne du plateau sous forme de bitboards, gère le tour des joueurs, les règles spéciales (roque, prise en passant, promotion) et valide les coups selon les règles officielles.</p>
<p>Elle fournit des méthodes pour interagir avec la logique du jeu, comme vérifier la validité d'un coup, générer les coups légaux pour une pièce donnée, et appliquer un mouvement. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a10c6ebea5a9efe93a887fcfc31dc7650" name="a10c6ebea5a9efe93a887fcfc31dc7650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10c6ebea5a9efe93a887fcfc31dc7650">&#9670;&#160;</a></span>getCurrentBoardState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; int, <a class="el" href="structJr_1_1Piece.html">Piece</a> &gt; Jr::ChessLogic::getCurrentBoardState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Récupère l'état complet du plateau sous forme de map case -&gt; pièce. </p>
<p>Utile pour l'affichage ou l'export du plateau.</p>
<dl class="section return"><dt>Returns</dt><dd>Map des cases (0-63) associées à la pièce présente. </dd></dl>

</div>
</div>
<a id="ae69b8bdbe7e4dadf7610533a8c8dd45c" name="ae69b8bdbe7e4dadf7610533a8c8dd45c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae69b8bdbe7e4dadf7610533a8c8dd45c">&#9670;&#160;</a></span>getLegalMoves()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; Jr::ChessLogic::getLegalMoves </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>from</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne la liste des coups légaux pour la pièce située à la case donnée. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>Case de la pièce (0-63). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vecteur des cases accessibles légalement. </dd></dl>

</div>
</div>
<a id="a253c319b5992443766b63fb62bea6abb" name="a253c319b5992443766b63fb62bea6abb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a253c319b5992443766b63fb62bea6abb">&#9670;&#160;</a></span>getPieceAtSquare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structJr_1_1Piece.html">Piece</a> Jr::ChessLogic::getPieceAtSquare </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>square</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtient la pièce située à une case donnée. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">square</td><td>Index de la case (0-63) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Objet <a class="el" href="structJr_1_1Piece.html" title="Structure représentant une pièce d&#39;échecs logique (sans aspects graphiques).">Piece</a> représentant la pièce, ou une pièce "vide" si aucune. </dd></dl>

</div>
</div>
<a id="a3300ac22961352cf51c4c05f539a01dd" name="a3300ac22961352cf51c4c05f539a01dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3300ac22961352cf51c4c05f539a01dd">&#9670;&#160;</a></span>getPromotionSquare()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Jr::ChessLogic::getPromotionSquare </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retourne la case où la promotion doit être effectuée. </p>
<dl class="section return"><dt>Returns</dt><dd>Index de la case (0-63), -1 si aucune promotion en attente. </dd></dl>

</div>
</div>
<a id="a6ba8ced0444457ad1871a9bdfedf965a" name="a6ba8ced0444457ad1871a9bdfedf965a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ba8ced0444457ad1871a9bdfedf965a">&#9670;&#160;</a></span>getPromotionWhite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Jr::ChessLogic::getPromotionWhite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indique la couleur du pion en promotion. </p>
<dl class="section return"><dt>Returns</dt><dd>true pour blanc, false pour noir. </dd></dl>

</div>
</div>
<a id="aa7c5db1773724ef1ea7529daefbb71fb" name="aa7c5db1773724ef1ea7529daefbb71fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7c5db1773724ef1ea7529daefbb71fb">&#9670;&#160;</a></span>getRawMoves()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; Jr::ChessLogic::getRawMoves </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structJr_1_1Piece.html">Piece</a> &amp;&#160;</td>
          <td class="paramname"><em>piece</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>from</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Génère les déplacements "bruts" possibles pour une pièce à une case donnée. </p>
<p>Ces mouvements ne tiennent pas compte de la mise en échec du roi ni d'autres règles avancées.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">piece</td><td>La pièce concernée. </td></tr>
    <tr><td class="paramname">from</td><td>La case d'origine (0-63). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vecteur d'indices de cases accessibles. </dd></dl>

</div>
</div>
<a id="a7e13a0213ea6fab80ebbb636bf05e9ff" name="a7e13a0213ea6fab80ebbb636bf05e9ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e13a0213ea6fab80ebbb636bf05e9ff">&#9670;&#160;</a></span>getWhiteTurn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Jr::ChessLogic::getWhiteTurn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtient le tour actuel. </p>
<dl class="section return"><dt>Returns</dt><dd>true si c'est le tour des blancs, false pour les noirs. </dd></dl>

</div>
</div>
<a id="a174fc9bcebb4078dea570be8ffd8dbb7" name="a174fc9bcebb4078dea570be8ffd8dbb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a174fc9bcebb4078dea570be8ffd8dbb7">&#9670;&#160;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Jr::ChessLogic::isEmpty </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sq</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vérifie si la case spécifiée est vide. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sq</td><td>Index de la case (0-63) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true si la case est vide, false sinon. </dd></dl>

</div>
</div>
<a id="a6896304132806f888290d52dcd3048bd" name="a6896304132806f888290d52dcd3048bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6896304132806f888290d52dcd3048bd">&#9670;&#160;</a></span>isEnemy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Jr::ChessLogic::isEnemy </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>whitePiece</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vérifie si la pièce à la case donnée est ennemie par rapport à la couleur spécifiée. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sq</td><td>Index de la case (0-63) </td></tr>
    <tr><td class="paramname">whitePiece</td><td>true si la pièce de référence est blanche, false si noire </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true si la pièce sur la case est adverse, false sinon. </dd></dl>

</div>
</div>
<a id="ab91c428d04308450340957bf716c8df7" name="ab91c428d04308450340957bf716c8df7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab91c428d04308450340957bf716c8df7">&#9670;&#160;</a></span>isKingInCheck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Jr::ChessLogic::isKingInCheck </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>whiteKing</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indique si le roi de la couleur spécifiée est en échec. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">whiteKing</td><td>true pour roi blanc, false pour roi noir. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true si le roi est en échec, false sinon. </dd></dl>

</div>
</div>
<a id="a80417575ab23dd5d822beb75694f5ddc" name="a80417575ab23dd5d822beb75694f5ddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80417575ab23dd5d822beb75694f5ddc">&#9670;&#160;</a></span>isPromotionPending()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Jr::ChessLogic::isPromotionPending </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indique si une promotion est en attente de choix. </p>
<dl class="section return"><dt>Returns</dt><dd>true si une promotion est en attente, false sinon. </dd></dl>

</div>
</div>
<a id="a43b8e42452b85679c562632d278dcfe9" name="a43b8e42452b85679c562632d278dcfe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43b8e42452b85679c562632d278dcfe9">&#9670;&#160;</a></span>isValidMove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Jr::ChessLogic::isValidMove </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vérifie si un mouvement est valide selon les règles du jeu. </p>
<p>Cette méthode valide la légalité complète, y compris la non-mise en échec du roi.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>Case d'origine du mouvement (0-63). </td></tr>
    <tr><td class="paramname">to</td><td>Case de destination (0-63). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true si le mouvement est légal, false sinon. </dd></dl>

</div>
</div>
<a id="a5845e6976c588fbc888a02c7d0196076" name="a5845e6976c588fbc888a02c7d0196076"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5845e6976c588fbc888a02c7d0196076">&#9670;&#160;</a></span>makeMove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Jr::ChessLogic::makeMove </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Effectue un coup valide et met à jour l'état du jeu. </p>
<p>Met à jour les bitboards, le tour, les droits au roque, prise en passant, promotion, etc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>Case d'origine (0-63). </td></tr>
    <tr><td class="paramname">to</td><td>Case de destination (0-63). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true si le mouvement a été effectué avec succès, false sinon (ex: coup illégal). </dd></dl>

</div>
</div>
<a id="ab15e4171c8645f7da53310f807723014" name="ab15e4171c8645f7da53310f807723014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab15e4171c8645f7da53310f807723014">&#9670;&#160;</a></span>promotePawn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Jr::ChessLogic::promotePawn </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>square</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PieceType&#160;</td>
          <td class="paramname"><em>newType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Effectue la promotion d'un pion à une case donnée vers un nouveau type de pièce. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">square</td><td>Case où la promotion doit avoir lieu (0-63). </td></tr>
    <tr><td class="paramname">newType</td><td>Type de pièce choisie pour la promotion (ex: Dame, Tour, Fou, Cavalier). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b57939b3aad263be45a3d3ce2d77867" name="a5b57939b3aad263be45a3d3ce2d77867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b57939b3aad263be45a3d3ce2d77867">&#9670;&#160;</a></span>wouldBeInCheck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Jr::ChessLogic::wouldBeInCheck </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>whiteKing</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vérifie si un coup hypothétique mettrait le roi en échec. </p>
<p>Utilisé pour valider la légalité des coups.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>Case d'origine (0-63). </td></tr>
    <tr><td class="paramname">to</td><td>Case de destination (0-63). </td></tr>
    <tr><td class="paramname">whiteKing</td><td>Couleur du roi à protéger (true = blanc). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true si le roi serait en échec après ce coup, false sinon. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/<a class="el" href="ChessLogic_8hpp_source.html">ChessLogic.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>Jr</b></li><li class="navelem"><a class="el" href="classJr_1_1ChessLogic.html">ChessLogic</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
