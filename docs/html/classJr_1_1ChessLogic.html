<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>JR SFML Chess Game: Jr::ChessLogic Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">JR SFML Chess Game
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classJr_1_1ChessLogic.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classJr_1_1ChessLogic-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Jr::ChessLogic Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Gestion complète de la logique d'un jeu d'échecs.  
 <a href="classJr_1_1ChessLogic.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ChessLogic_8hpp_source.html">ChessLogic.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a253c319b5992443766b63fb62bea6abb" id="r_a253c319b5992443766b63fb62bea6abb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structJr_1_1Piece.html">Piece</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classJr_1_1ChessLogic.html#a253c319b5992443766b63fb62bea6abb">getPieceAtSquare</a> (int square) const</td></tr>
<tr class="memdesc:a253c319b5992443766b63fb62bea6abb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtient la pièce située à une case donnée.  <br /></td></tr>
<tr class="separator:a253c319b5992443766b63fb62bea6abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa88200f0181256b91dd30b640a059e2d" id="r_aa88200f0181256b91dd30b640a059e2d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classJr_1_1ChessLogic.html#aa88200f0181256b91dd30b640a059e2d">ChessLogic</a> ()</td></tr>
<tr class="memdesc:aa88200f0181256b91dd30b640a059e2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructeur par défaut. Initialise l'état interne pour une partie fraîche.  <br /></td></tr>
<tr class="separator:aa88200f0181256b91dd30b640a059e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a424e4a7e07f392783456305bfe833052" id="r_a424e4a7e07f392783456305bfe833052"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classJr_1_1ChessLogic.html#a424e4a7e07f392783456305bfe833052">initializeBoard</a> ()</td></tr>
<tr class="memdesc:a424e4a7e07f392783456305bfe833052"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise la position de départ du plateau (placement initial des pièces). Réinitialise aussi toutes les variables d'état (roque, promotion, etc).  <br /></td></tr>
<tr class="separator:a424e4a7e07f392783456305bfe833052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b8e42452b85679c562632d278dcfe9" id="r_a43b8e42452b85679c562632d278dcfe9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classJr_1_1ChessLogic.html#a43b8e42452b85679c562632d278dcfe9">isValidMove</a> (int from, int to) const</td></tr>
<tr class="memdesc:a43b8e42452b85679c562632d278dcfe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vérifie si un mouvement est valide selon les règles du jeu.  <br /></td></tr>
<tr class="separator:a43b8e42452b85679c562632d278dcfe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5845e6976c588fbc888a02c7d0196076" id="r_a5845e6976c588fbc888a02c7d0196076"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classJr_1_1ChessLogic.html#a5845e6976c588fbc888a02c7d0196076">makeMove</a> (int from, int to)</td></tr>
<tr class="memdesc:a5845e6976c588fbc888a02c7d0196076"><td class="mdescLeft">&#160;</td><td class="mdescRight">Effectue un coup valide et met à jour l'état du jeu.  <br /></td></tr>
<tr class="separator:a5845e6976c588fbc888a02c7d0196076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae69b8bdbe7e4dadf7610533a8c8dd45c" id="r_ae69b8bdbe7e4dadf7610533a8c8dd45c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classJr_1_1ChessLogic.html#ae69b8bdbe7e4dadf7610533a8c8dd45c">getLegalMoves</a> (int from) const</td></tr>
<tr class="memdesc:ae69b8bdbe7e4dadf7610533a8c8dd45c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne la liste des coups légaux pour la pièce située à la case donnée.  <br /></td></tr>
<tr class="separator:ae69b8bdbe7e4dadf7610533a8c8dd45c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab91c428d04308450340957bf716c8df7" id="r_ab91c428d04308450340957bf716c8df7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classJr_1_1ChessLogic.html#ab91c428d04308450340957bf716c8df7">isKingInCheck</a> (bool whiteKing) const</td></tr>
<tr class="memdesc:ab91c428d04308450340957bf716c8df7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indique si le roi de la couleur spécifiée est en échec.  <br /></td></tr>
<tr class="separator:ab91c428d04308450340957bf716c8df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b57939b3aad263be45a3d3ce2d77867" id="r_a5b57939b3aad263be45a3d3ce2d77867"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classJr_1_1ChessLogic.html#a5b57939b3aad263be45a3d3ce2d77867">wouldBeInCheck</a> (int from, int to, bool whiteKing) const</td></tr>
<tr class="memdesc:a5b57939b3aad263be45a3d3ce2d77867"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vérifie si un coup hypothétique mettrait le roi en échec.  <br /></td></tr>
<tr class="separator:a5b57939b3aad263be45a3d3ce2d77867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e13a0213ea6fab80ebbb636bf05e9ff" id="r_a7e13a0213ea6fab80ebbb636bf05e9ff"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classJr_1_1ChessLogic.html#a7e13a0213ea6fab80ebbb636bf05e9ff">getWhiteTurn</a> () const</td></tr>
<tr class="memdesc:a7e13a0213ea6fab80ebbb636bf05e9ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtient le tour actuel.  <br /></td></tr>
<tr class="separator:a7e13a0213ea6fab80ebbb636bf05e9ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80417575ab23dd5d822beb75694f5ddc" id="r_a80417575ab23dd5d822beb75694f5ddc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classJr_1_1ChessLogic.html#a80417575ab23dd5d822beb75694f5ddc">isPromotionPending</a> () const</td></tr>
<tr class="memdesc:a80417575ab23dd5d822beb75694f5ddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indique si une promotion est en attente de choix.  <br /></td></tr>
<tr class="separator:a80417575ab23dd5d822beb75694f5ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ba8ced0444457ad1871a9bdfedf965a" id="r_a6ba8ced0444457ad1871a9bdfedf965a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classJr_1_1ChessLogic.html#a6ba8ced0444457ad1871a9bdfedf965a">getPromotionWhite</a> () const</td></tr>
<tr class="memdesc:a6ba8ced0444457ad1871a9bdfedf965a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indique la couleur du pion en promotion.  <br /></td></tr>
<tr class="separator:a6ba8ced0444457ad1871a9bdfedf965a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3300ac22961352cf51c4c05f539a01dd" id="r_a3300ac22961352cf51c4c05f539a01dd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classJr_1_1ChessLogic.html#a3300ac22961352cf51c4c05f539a01dd">getPromotionSquare</a> () const</td></tr>
<tr class="memdesc:a3300ac22961352cf51c4c05f539a01dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne la case où la promotion doit être effectuée.  <br /></td></tr>
<tr class="separator:a3300ac22961352cf51c4c05f539a01dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15e4171c8645f7da53310f807723014" id="r_ab15e4171c8645f7da53310f807723014"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classJr_1_1ChessLogic.html#ab15e4171c8645f7da53310f807723014">promotePawn</a> (int square, PieceType newType)</td></tr>
<tr class="memdesc:ab15e4171c8645f7da53310f807723014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Effectue la promotion d'un pion à une case donnée vers un nouveau type de pièce.  <br /></td></tr>
<tr class="separator:ab15e4171c8645f7da53310f807723014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10c6ebea5a9efe93a887fcfc31dc7650" id="r_a10c6ebea5a9efe93a887fcfc31dc7650"><td class="memItemLeft" align="right" valign="top">std::map&lt; int, <a class="el" href="structJr_1_1Piece.html">Piece</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classJr_1_1ChessLogic.html#a10c6ebea5a9efe93a887fcfc31dc7650">getCurrentBoardState</a> () const</td></tr>
<tr class="memdesc:a10c6ebea5a9efe93a887fcfc31dc7650"><td class="mdescLeft">&#160;</td><td class="mdescRight">Récupère l'état complet du plateau sous forme de map case -&gt; pièce.  <br /></td></tr>
<tr class="separator:a10c6ebea5a9efe93a887fcfc31dc7650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf60e8e8c977e1b4da98424a1e6ebfa4" id="r_aaf60e8e8c977e1b4da98424a1e6ebfa4"><td class="memItemLeft" align="right" valign="top">ChessGameStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classJr_1_1ChessLogic.html#aaf60e8e8c977e1b4da98424a1e6ebfa4">getGameState</a> () const</td></tr>
<tr class="memdesc:aaf60e8e8c977e1b4da98424a1e6ebfa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vérifie si le jeu est terminé (échec, pat, etc.).  <br /></td></tr>
<tr class="separator:aaf60e8e8c977e1b4da98424a1e6ebfa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f992522dea5ba44b99f839356df4f83" id="r_a3f992522dea5ba44b99f839356df4f83"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classJr_1_1ChessLogic.html#a3f992522dea5ba44b99f839356df4f83">isStalemate</a> () const</td></tr>
<tr class="memdesc:a3f992522dea5ba44b99f839356df4f83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vérifie si la partie est un match nul par pat (stalemate).  <br /></td></tr>
<tr class="separator:a3f992522dea5ba44b99f839356df4f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d4a612b69f640ce82998c957183c1c9" id="r_a0d4a612b69f640ce82998c957183c1c9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classJr_1_1ChessLogic.html#a0d4a612b69f640ce82998c957183c1c9">isInsufficientMaterial</a> () const</td></tr>
<tr class="memdesc:a0d4a612b69f640ce82998c957183c1c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vérifie si la partie est un match nul par matériel insuffisant.  <br /></td></tr>
<tr class="separator:a0d4a612b69f640ce82998c957183c1c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22f2ef871ab03cb649074d3fcefb2ff5" id="r_a22f2ef871ab03cb649074d3fcefb2ff5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classJr_1_1ChessLogic.html#a22f2ef871ab03cb649074d3fcefb2ff5">is50MoveRuleDraw</a> () const</td></tr>
<tr class="memdesc:a22f2ef871ab03cb649074d3fcefb2ff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vérifie si la partie est un match nul par la règle des 50 coups sans capture ni mouvement de pion.  <br /></td></tr>
<tr class="separator:a22f2ef871ab03cb649074d3fcefb2ff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9222446b34ffaf4dff45d44c06c57a50" id="r_a9222446b34ffaf4dff45d44c06c57a50"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classJr_1_1ChessLogic.html#a9222446b34ffaf4dff45d44c06c57a50">isThreeFoldRepetitionDraw</a> () const</td></tr>
<tr class="memdesc:a9222446b34ffaf4dff45d44c06c57a50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vérifie si la partie est un match nul par répétition de position.  <br /></td></tr>
<tr class="separator:a9222446b34ffaf4dff45d44c06c57a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f21a6cb5abfc2c622028dcc69129a61" id="r_a9f21a6cb5abfc2c622028dcc69129a61"><td class="memItemLeft" align="right" valign="top"><a id="a9f21a6cb5abfc2c622028dcc69129a61" name="a9f21a6cb5abfc2c622028dcc69129a61"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>noLegalMovesAvailable</b> (bool whiteToMove) const</td></tr>
<tr class="separator:a9f21a6cb5abfc2c622028dcc69129a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7ebe16842226c78b06e8b03747f0e45" id="r_ab7ebe16842226c78b06e8b03747f0e45"><td class="memItemLeft" align="right" valign="top"><a id="ab7ebe16842226c78b06e8b03747f0e45" name="ab7ebe16842226c78b06e8b03747f0e45"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isCheckmate</b> (bool whiteToMove) const</td></tr>
<tr class="separator:ab7ebe16842226c78b06e8b03747f0e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f75c5545e07b160c9b5c7c6deee7224" id="r_a9f75c5545e07b160c9b5c7c6deee7224"><td class="memItemLeft" align="right" valign="top"><a id="a9f75c5545e07b160c9b5c7c6deee7224" name="a9f75c5545e07b160c9b5c7c6deee7224"></a>
const std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getMoveHistory</b> () const</td></tr>
<tr class="separator:a9f75c5545e07b160c9b5c7c6deee7224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9865a9b72e3a4d533b58af0db20b6c0b" id="r_a9865a9b72e3a4d533b58af0db20b6c0b"><td class="memItemLeft" align="right" valign="top"><a id="a9865a9b72e3a4d533b58af0db20b6c0b" name="a9865a9b72e3a4d533b58af0db20b6c0b"></a>
const std::vector&lt; <a class="el" href="structJr_1_1Piece.html">Piece</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getCapturedByWhite</b> () const</td></tr>
<tr class="separator:a9865a9b72e3a4d533b58af0db20b6c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eca85a5a6e014a5d88508acce634b84" id="r_a4eca85a5a6e014a5d88508acce634b84"><td class="memItemLeft" align="right" valign="top"><a id="a4eca85a5a6e014a5d88508acce634b84" name="a4eca85a5a6e014a5d88508acce634b84"></a>
const std::vector&lt; <a class="el" href="structJr_1_1Piece.html">Piece</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getCapturedByBlack</b> () const</td></tr>
<tr class="separator:a4eca85a5a6e014a5d88508acce634b84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367afe71b334d0b0b48328df0bd2cdf5" id="r_a367afe71b334d0b0b48328df0bd2cdf5"><td class="memItemLeft" align="right" valign="top"><a id="a367afe71b334d0b0b48328df0bd2cdf5" name="a367afe71b334d0b0b48328df0bd2cdf5"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getSnapshotCount</b> () const</td></tr>
<tr class="separator:a367afe71b334d0b0b48328df0bd2cdf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a235f30310c388a927148b7ea2ab8d37b" id="r_a235f30310c388a927148b7ea2ab8d37b"><td class="memItemLeft" align="right" valign="top"><a id="a235f30310c388a927148b7ea2ab8d37b" name="a235f30310c388a927148b7ea2ab8d37b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getCurrentSnapshotIndex</b> () const</td></tr>
<tr class="separator:a235f30310c388a927148b7ea2ab8d37b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae85979ea1581e8fea6336787c3f632d5" id="r_ae85979ea1581e8fea6336787c3f632d5"><td class="memItemLeft" align="right" valign="top"><a id="ae85979ea1581e8fea6336787c3f632d5" name="ae85979ea1581e8fea6336787c3f632d5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>restoreSnapshot</b> (int index)</td></tr>
<tr class="separator:ae85979ea1581e8fea6336787c3f632d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae402c5cbaa4ecc44610506ddea09f8db" id="r_ae402c5cbaa4ecc44610506ddea09f8db"><td class="memItemLeft" align="right" valign="top"><a id="ae402c5cbaa4ecc44610506ddea09f8db" name="ae402c5cbaa4ecc44610506ddea09f8db"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getMaterialScoreDifference</b> () const</td></tr>
<tr class="separator:ae402c5cbaa4ecc44610506ddea09f8db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a174fc9bcebb4078dea570be8ffd8dbb7" id="r_a174fc9bcebb4078dea570be8ffd8dbb7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classJr_1_1ChessLogic.html#a174fc9bcebb4078dea570be8ffd8dbb7">isEmpty</a> (int sq) const</td></tr>
<tr class="memdesc:a174fc9bcebb4078dea570be8ffd8dbb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vérifie si la case spécifiée est vide.  <br /></td></tr>
<tr class="separator:a174fc9bcebb4078dea570be8ffd8dbb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6896304132806f888290d52dcd3048bd" id="r_a6896304132806f888290d52dcd3048bd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classJr_1_1ChessLogic.html#a6896304132806f888290d52dcd3048bd">isEnemy</a> (int sq, bool whitePiece) const</td></tr>
<tr class="memdesc:a6896304132806f888290d52dcd3048bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vérifie si la pièce à la case donnée est ennemie par rapport à la couleur spécifiée.  <br /></td></tr>
<tr class="separator:a6896304132806f888290d52dcd3048bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7c5db1773724ef1ea7529daefbb71fb" id="r_aa7c5db1773724ef1ea7529daefbb71fb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classJr_1_1ChessLogic.html#aa7c5db1773724ef1ea7529daefbb71fb">getRawMoves</a> (const <a class="el" href="structJr_1_1Piece.html">Piece</a> &amp;piece, int from) const</td></tr>
<tr class="memdesc:aa7c5db1773724ef1ea7529daefbb71fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Génère les déplacements "bruts" possibles pour une pièce à une case donnée.  <br /></td></tr>
<tr class="separator:aa7c5db1773724ef1ea7529daefbb71fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f16a597f05a914fd3d0ba9eeb56468" id="r_ab3f16a597f05a914fd3d0ba9eeb56468"><td class="memItemLeft" align="right" valign="top"><a id="ab3f16a597f05a914fd3d0ba9eeb56468" name="ab3f16a597f05a914fd3d0ba9eeb56468"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>generateZobristKeys</b> ()</td></tr>
<tr class="separator:ab3f16a597f05a914fd3d0ba9eeb56468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c114ae073d2285ed352509e0d849408" id="r_a2c114ae073d2285ed352509e0d849408"><td class="memItemLeft" align="right" valign="top"><a id="a2c114ae073d2285ed352509e0d849408" name="a2c114ae073d2285ed352509e0d849408"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>calculateZobristHash</b> () const</td></tr>
<tr class="separator:a2c114ae073d2285ed352509e0d849408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a1a62ccedd946582c6f84915612b733" id="r_a5a1a62ccedd946582c6f84915612b733"><td class="memItemLeft" align="right" valign="top"><a id="a5a1a62ccedd946582c6f84915612b733" name="a5a1a62ccedd946582c6f84915612b733"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>updateZobristHashForMove</b> (const <a class="el" href="structJr_1_1Piece.html">Piece</a> &amp;movingPiece, int from, int to, const <a class="el" href="structJr_1_1Piece.html">Piece</a> &amp;capturedPiece, int capturedPawnSq, bool isCastling, int rookFrom=-1, int rookTo=-1, PieceType promotionType=PieceType::None)</td></tr>
<tr class="separator:a5a1a62ccedd946582c6f84915612b733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe9a39bf9dc19d15bf3bad05ee376e1e" id="r_abe9a39bf9dc19d15bf3bad05ee376e1e"><td class="memItemLeft" align="right" valign="top"><a id="abe9a39bf9dc19d15bf3bad05ee376e1e" name="abe9a39bf9dc19d15bf3bad05ee376e1e"></a>
<a class="el" href="structJr_1_1Snapshot.html">Snapshot</a>&#160;</td><td class="memItemRight" valign="bottom"><b>createSnapshot</b> () const</td></tr>
<tr class="separator:abe9a39bf9dc19d15bf3bad05ee376e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a132d6e05d7474788d7f473324d0f9c39" id="r_a132d6e05d7474788d7f473324d0f9c39"><td class="memItemLeft" align="right" valign="top"><a id="a132d6e05d7474788d7f473324d0f9c39" name="a132d6e05d7474788d7f473324d0f9c39"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>generatePGNMove</b> (int from, int to, const <a class="el" href="structJr_1_1Piece.html">Piece</a> &amp;movingPiece, bool isCapture, bool isCheck, bool isCheckmate) const</td></tr>
<tr class="separator:a132d6e05d7474788d7f473324d0f9c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:af8aefeb9fca02b3ff5b8e9d80290f3bc" id="r_af8aefeb9fca02b3ff5b8e9d80290f3bc"><td class="memItemLeft" align="right" valign="top"><a id="af8aefeb9fca02b3ff5b8e9d80290f3bc" name="af8aefeb9fca02b3ff5b8e9d80290f3bc"></a>
std::map&lt; std::string, uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>bitboards</b></td></tr>
<tr class="memdesc:af8aefeb9fca02b3ff5b8e9d80290f3bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitboards représentant la position de chaque type de pièce, identifiées par une chaîne (ex: "wP" pour pions blancs) <br /></td></tr>
<tr class="separator:af8aefeb9fca02b3ff5b8e9d80290f3bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bba0589ab6ff1f114574efea823987c" id="r_a8bba0589ab6ff1f114574efea823987c"><td class="memItemLeft" align="right" valign="top"><a id="a8bba0589ab6ff1f114574efea823987c" name="a8bba0589ab6ff1f114574efea823987c"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>bitboardPieces</b></td></tr>
<tr class="memdesc:a8bba0589ab6ff1f114574efea823987c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitboard représentant toutes les cases occupées par une pièce (blanche ou noire) <br /></td></tr>
<tr class="separator:a8bba0589ab6ff1f114574efea823987c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a350db9fdba71b42b7a2130c6a0af4f15" id="r_a350db9fdba71b42b7a2130c6a0af4f15"><td class="memItemLeft" align="right" valign="top"><a id="a350db9fdba71b42b7a2130c6a0af4f15" name="a350db9fdba71b42b7a2130c6a0af4f15"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>whiteTurn</b> = true</td></tr>
<tr class="memdesc:a350db9fdba71b42b7a2130c6a0af4f15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indique si c'est au tour des blancs de jouer (true) ou des noirs (false) <br /></td></tr>
<tr class="separator:a350db9fdba71b42b7a2130c6a0af4f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af864c0ba865802ae46c4745b2ba38864" id="r_af864c0ba865802ae46c4745b2ba38864"><td class="memItemLeft" align="right" valign="top"><a id="af864c0ba865802ae46c4745b2ba38864" name="af864c0ba865802ae46c4745b2ba38864"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>enPassantSquare</b> = -1</td></tr>
<tr class="memdesc:af864c0ba865802ae46c4745b2ba38864"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index de la case cible d'une prise en passant possible, ou -1 si aucune. <br /></td></tr>
<tr class="separator:af864c0ba865802ae46c4745b2ba38864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10029e34006ec074a14e832dea28a850" id="r_a10029e34006ec074a14e832dea28a850"><td class="memItemLeft" align="right" valign="top"><a id="a10029e34006ec074a14e832dea28a850" name="a10029e34006ec074a14e832dea28a850"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>whiteKingMoved</b> = false</td></tr>
<tr class="memdesc:a10029e34006ec074a14e832dea28a850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indique si le roi blanc a déjà bougé (affecte la possibilité de roque) <br /></td></tr>
<tr class="separator:a10029e34006ec074a14e832dea28a850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eea1b97becdece30c39aa3437f1d348" id="r_a5eea1b97becdece30c39aa3437f1d348"><td class="memItemLeft" align="right" valign="top"><a id="a5eea1b97becdece30c39aa3437f1d348" name="a5eea1b97becdece30c39aa3437f1d348"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>whiteRookKingsideMoved</b> = false</td></tr>
<tr class="memdesc:a5eea1b97becdece30c39aa3437f1d348"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indique si la tour blanche côté roi a déjà bougé <br /></td></tr>
<tr class="separator:a5eea1b97becdece30c39aa3437f1d348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2183d25bd688aecf98285d03df5e18c2" id="r_a2183d25bd688aecf98285d03df5e18c2"><td class="memItemLeft" align="right" valign="top"><a id="a2183d25bd688aecf98285d03df5e18c2" name="a2183d25bd688aecf98285d03df5e18c2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>whiteRookQueensideMoved</b> = false</td></tr>
<tr class="memdesc:a2183d25bd688aecf98285d03df5e18c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indique si la tour blanche côté dame a déjà bougé <br /></td></tr>
<tr class="separator:a2183d25bd688aecf98285d03df5e18c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cfa167d2093c5cdf3aed759c1db1f7a" id="r_a3cfa167d2093c5cdf3aed759c1db1f7a"><td class="memItemLeft" align="right" valign="top"><a id="a3cfa167d2093c5cdf3aed759c1db1f7a" name="a3cfa167d2093c5cdf3aed759c1db1f7a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>blackKingMoved</b> = false</td></tr>
<tr class="memdesc:a3cfa167d2093c5cdf3aed759c1db1f7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indique si le roi noir a déjà bougé <br /></td></tr>
<tr class="separator:a3cfa167d2093c5cdf3aed759c1db1f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a696b35251f237859a68c842d0e039dc2" id="r_a696b35251f237859a68c842d0e039dc2"><td class="memItemLeft" align="right" valign="top"><a id="a696b35251f237859a68c842d0e039dc2" name="a696b35251f237859a68c842d0e039dc2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>blackRookKingsideMoved</b> = false</td></tr>
<tr class="memdesc:a696b35251f237859a68c842d0e039dc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indique si la tour noire côté roi a déjà bougé <br /></td></tr>
<tr class="separator:a696b35251f237859a68c842d0e039dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f03032d03c8193b446ebf9c59e65945" id="r_a0f03032d03c8193b446ebf9c59e65945"><td class="memItemLeft" align="right" valign="top"><a id="a0f03032d03c8193b446ebf9c59e65945" name="a0f03032d03c8193b446ebf9c59e65945"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>blackRookQueensideMoved</b> = false</td></tr>
<tr class="memdesc:a0f03032d03c8193b446ebf9c59e65945"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indique si la tour noire côté dame a déjà bougé <br /></td></tr>
<tr class="separator:a0f03032d03c8193b446ebf9c59e65945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c0d618f23332050c01363f69e3f56f" id="r_af4c0d618f23332050c01363f69e3f56f"><td class="memItemLeft" align="right" valign="top"><a id="af4c0d618f23332050c01363f69e3f56f" name="af4c0d618f23332050c01363f69e3f56f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>promotionPending</b> = false</td></tr>
<tr class="memdesc:af4c0d618f23332050c01363f69e3f56f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indique si une promotion de pion est en attente. <br /></td></tr>
<tr class="separator:af4c0d618f23332050c01363f69e3f56f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87e877526a56eebed35c206b4f711df3" id="r_a87e877526a56eebed35c206b4f711df3"><td class="memItemLeft" align="right" valign="top"><a id="a87e877526a56eebed35c206b4f711df3" name="a87e877526a56eebed35c206b4f711df3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>promotionWhite</b> = true</td></tr>
<tr class="memdesc:a87e877526a56eebed35c206b4f711df3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indique si la promotion concerne un pion blanc (true) ou noir (false) <br /></td></tr>
<tr class="separator:a87e877526a56eebed35c206b4f711df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57c4bec58b26aaed18110c963c280d88" id="r_a57c4bec58b26aaed18110c963c280d88"><td class="memItemLeft" align="right" valign="top"><a id="a57c4bec58b26aaed18110c963c280d88" name="a57c4bec58b26aaed18110c963c280d88"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>promotionSquare</b> = -1</td></tr>
<tr class="memdesc:a57c4bec58b26aaed18110c963c280d88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Case où la promotion doit avoir lieu (index), -1 si aucune promotion en attente. <br /></td></tr>
<tr class="separator:a57c4bec58b26aaed18110c963c280d88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3db80ac44ad5b94e2bdf6e541b6d5d86" id="r_a3db80ac44ad5b94e2bdf6e541b6d5d86"><td class="memItemLeft" align="right" valign="top"><a id="a3db80ac44ad5b94e2bdf6e541b6d5d86" name="a3db80ac44ad5b94e2bdf6e541b6d5d86"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>fiftyMoveCounter</b></td></tr>
<tr class="separator:a3db80ac44ad5b94e2bdf6e541b6d5d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32ec321d2473fca170edd1c28282add8" id="r_a32ec321d2473fca170edd1c28282add8"><td class="memItemLeft" align="right" valign="top"><a id="a32ec321d2473fca170edd1c28282add8" name="a32ec321d2473fca170edd1c28282add8"></a>
std::vector&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>positionHistory</b></td></tr>
<tr class="separator:a32ec321d2473fca170edd1c28282add8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3353b8c0751236937b4ec7e5f7afb945" id="r_a3353b8c0751236937b4ec7e5f7afb945"><td class="memItemLeft" align="right" valign="top"><a id="a3353b8c0751236937b4ec7e5f7afb945" name="a3353b8c0751236937b4ec7e5f7afb945"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>currentZobristHash</b></td></tr>
<tr class="separator:a3353b8c0751236937b4ec7e5f7afb945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1028aa66d36d9fe95d0b45606e04408" id="r_aa1028aa66d36d9fe95d0b45606e04408"><td class="memItemLeft" align="right" valign="top"><a id="aa1028aa66d36d9fe95d0b45606e04408" name="aa1028aa66d36d9fe95d0b45606e04408"></a>
std::map&lt; std::string, uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ZobristPieceKeys</b> [64]</td></tr>
<tr class="separator:aa1028aa66d36d9fe95d0b45606e04408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae02d729fcd6ee193fc86bfc762358a8e" id="r_ae02d729fcd6ee193fc86bfc762358a8e"><td class="memItemLeft" align="right" valign="top"><a id="ae02d729fcd6ee193fc86bfc762358a8e" name="ae02d729fcd6ee193fc86bfc762358a8e"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZobristSideToMoveKey</b></td></tr>
<tr class="separator:ae02d729fcd6ee193fc86bfc762358a8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae56c70986363458731631892aaf323dc" id="r_ae56c70986363458731631892aaf323dc"><td class="memItemLeft" align="right" valign="top"><a id="ae56c70986363458731631892aaf323dc" name="ae56c70986363458731631892aaf323dc"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZobristCastlingKeys</b> [16]</td></tr>
<tr class="separator:ae56c70986363458731631892aaf323dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac498c141d64500d711dbca8cfb2e64e2" id="r_ac498c141d64500d711dbca8cfb2e64e2"><td class="memItemLeft" align="right" valign="top"><a id="ac498c141d64500d711dbca8cfb2e64e2" name="ac498c141d64500d711dbca8cfb2e64e2"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZobristEnPassantKeys</b> [8]</td></tr>
<tr class="separator:ac498c141d64500d711dbca8cfb2e64e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab550168171c6a640f96138bca5663792" id="r_ab550168171c6a640f96138bca5663792"><td class="memItemLeft" align="right" valign="top"><a id="ab550168171c6a640f96138bca5663792" name="ab550168171c6a640f96138bca5663792"></a>
std::vector&lt; <a class="el" href="structJr_1_1Snapshot.html">Snapshot</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>snapshots</b></td></tr>
<tr class="separator:ab550168171c6a640f96138bca5663792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea5bcbcb8caac42d9da9db3c73139427" id="r_aea5bcbcb8caac42d9da9db3c73139427"><td class="memItemLeft" align="right" valign="top"><a id="aea5bcbcb8caac42d9da9db3c73139427" name="aea5bcbcb8caac42d9da9db3c73139427"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>currentSnapshotIndex</b> = 0</td></tr>
<tr class="separator:aea5bcbcb8caac42d9da9db3c73139427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a436dcece7f4ce74ce52127fd4c658710" id="r_a436dcece7f4ce74ce52127fd4c658710"><td class="memItemLeft" align="right" valign="top"><a id="a436dcece7f4ce74ce52127fd4c658710" name="a436dcece7f4ce74ce52127fd4c658710"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>moveHistory</b></td></tr>
<tr class="separator:a436dcece7f4ce74ce52127fd4c658710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a2f2a9104c7274b48ca916b6e4f34a5" id="r_a8a2f2a9104c7274b48ca916b6e4f34a5"><td class="memItemLeft" align="right" valign="top"><a id="a8a2f2a9104c7274b48ca916b6e4f34a5" name="a8a2f2a9104c7274b48ca916b6e4f34a5"></a>
std::vector&lt; <a class="el" href="structJr_1_1Piece.html">Piece</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>capturedByWhite</b></td></tr>
<tr class="separator:a8a2f2a9104c7274b48ca916b6e4f34a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82bf8adfba2f35fa0603411da088d3fe" id="r_a82bf8adfba2f35fa0603411da088d3fe"><td class="memItemLeft" align="right" valign="top"><a id="a82bf8adfba2f35fa0603411da088d3fe" name="a82bf8adfba2f35fa0603411da088d3fe"></a>
std::vector&lt; <a class="el" href="structJr_1_1Piece.html">Piece</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>capturedByBlack</b></td></tr>
<tr class="separator:a82bf8adfba2f35fa0603411da088d3fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Gestion complète de la logique d'un jeu d'échecs. </p>
<p>Cette classe maintient l'état interne du plateau sous forme de bitboards, gère le tour des joueurs, les règles spéciales (roque, prise en passant, promotion) et valide les coups selon les règles officielles.</p>
<p>Elle fournit des méthodes pour interagir avec la logique du jeu, comme vérifier la validité d'un coup, générer les coups légaux pour une pièce donnée, et appliquer un mouvement. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa88200f0181256b91dd30b640a059e2d" name="aa88200f0181256b91dd30b640a059e2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa88200f0181256b91dd30b640a059e2d">&#9670;&#160;</a></span>ChessLogic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Jr::ChessLogic::ChessLogic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructeur par défaut. Initialise l'état interne pour une partie fraîche. </p>
<p>Constructeur de la classe <a class="el" href="classJr_1_1ChessLogic.html" title="Gestion complète de la logique d&#39;un jeu d&#39;échecs.">ChessLogic</a>. Initialise l'état du plateau de jeu à sa configuration de départ standard. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a10c6ebea5a9efe93a887fcfc31dc7650" name="a10c6ebea5a9efe93a887fcfc31dc7650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10c6ebea5a9efe93a887fcfc31dc7650">&#9670;&#160;</a></span>getCurrentBoardState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; int, <a class="el" href="structJr_1_1Piece.html">Piece</a> &gt; Jr::ChessLogic::getCurrentBoardState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Récupère l'état complet du plateau sous forme de map case -&gt; pièce. </p>
<p>Fournit l'état actuel du plateau de jeu sous une forme facilement utilisable pour l'affichage. Convertit les bitboards internes en une map qui associe chaque case occupée à un objet <a class="el" href="structJr_1_1Piece.html" title="Structure représentant une pièce d&#39;échecs logique (sans aspects graphiques).">Piece</a>.</p>
<p>Utile pour l'affichage ou l'export du plateau.</p>
<dl class="section return"><dt>Returns</dt><dd>Map des cases (0-63) associées à la pièce présente.</dd>
<dd>
Une std::map&lt;int, Piece&gt; où la clé est l'index de la case (0-63) et la valeur est l'objet <a class="el" href="structJr_1_1Piece.html" title="Structure représentant une pièce d&#39;échecs logique (sans aspects graphiques).">Piece</a>. </dd></dl>

</div>
</div>
<a id="aaf60e8e8c977e1b4da98424a1e6ebfa4" name="aaf60e8e8c977e1b4da98424a1e6ebfa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf60e8e8c977e1b4da98424a1e6ebfa4">&#9670;&#160;</a></span>getGameState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ChessGameStatus Jr::ChessLogic::getGameState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vérifie si le jeu est terminé (échec, pat, etc.). </p>
<p>Cette méthode évalue l'état du jeu pour déterminer s'il y a un gagnant, un match nul, ou si le jeu continue.</p>
<dl class="section return"><dt>Returns</dt><dd>L'état actuel du jeu (en cours, échec et mat, pat, etc.). </dd></dl>

</div>
</div>
<a id="ae69b8bdbe7e4dadf7610533a8c8dd45c" name="ae69b8bdbe7e4dadf7610533a8c8dd45c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae69b8bdbe7e4dadf7610533a8c8dd45c">&#9670;&#160;</a></span>getLegalMoves()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; Jr::ChessLogic::getLegalMoves </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>from</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne la liste des coups légaux pour la pièce située à la case donnée. </p>
<p>Récupère tous les coups légaux pour une pièce à partir d'une case donnée. Cette fonction combine les mouvements bruts avec les vérifications d'échec pour s'assurer que seuls les coups valides (qui ne laissent pas le roi en échec) sont retournés. Inclut également la logique spécifique du roque.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>Case de la pièce (0-63). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vecteur des cases accessibles légalement.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>L'index de la case de départ de la pièce. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Un vecteur d'entiers représentant les index des cases cibles légales. </dd></dl>

</div>
</div>
<a id="a253c319b5992443766b63fb62bea6abb" name="a253c319b5992443766b63fb62bea6abb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a253c319b5992443766b63fb62bea6abb">&#9670;&#160;</a></span>getPieceAtSquare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structJr_1_1Piece.html">Piece</a> Jr::ChessLogic::getPieceAtSquare </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>square</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtient la pièce située à une case donnée. </p>
<p>Récupère l'objet <a class="el" href="structJr_1_1Piece.html" title="Structure représentant une pièce d&#39;échecs logique (sans aspects graphiques).">Piece</a> (type et couleur) à une case donnée. Parcourt les bitboards pour identifier quelle pièce se trouve à la position spécifiée.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">square</td><td>Index de la case (0-63) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Objet <a class="el" href="structJr_1_1Piece.html" title="Structure représentant une pièce d&#39;échecs logique (sans aspects graphiques).">Piece</a> représentant la pièce, ou une pièce "vide" si aucune.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">square</td><td>L'index de la case (0-63). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>L'objet <a class="el" href="structJr_1_1Piece.html" title="Structure représentant une pièce d&#39;échecs logique (sans aspects graphiques).">Piece</a> trouvé à la case. Si la case est vide ou invalide, retourne une <a class="el" href="structJr_1_1Piece.html" title="Structure représentant une pièce d&#39;échecs logique (sans aspects graphiques).">Piece</a> vide. </dd></dl>

</div>
</div>
<a id="a3300ac22961352cf51c4c05f539a01dd" name="a3300ac22961352cf51c4c05f539a01dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3300ac22961352cf51c4c05f539a01dd">&#9670;&#160;</a></span>getPromotionSquare()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Jr::ChessLogic::getPromotionSquare </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retourne la case où la promotion doit être effectuée. </p>
<dl class="section return"><dt>Returns</dt><dd>Index de la case (0-63), -1 si aucune promotion en attente. </dd></dl>

</div>
</div>
<a id="a6ba8ced0444457ad1871a9bdfedf965a" name="a6ba8ced0444457ad1871a9bdfedf965a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ba8ced0444457ad1871a9bdfedf965a">&#9670;&#160;</a></span>getPromotionWhite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Jr::ChessLogic::getPromotionWhite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indique la couleur du pion en promotion. </p>
<dl class="section return"><dt>Returns</dt><dd>true pour blanc, false pour noir. </dd></dl>

</div>
</div>
<a id="aa7c5db1773724ef1ea7529daefbb71fb" name="aa7c5db1773724ef1ea7529daefbb71fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7c5db1773724ef1ea7529daefbb71fb">&#9670;&#160;</a></span>getRawMoves()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; Jr::ChessLogic::getRawMoves </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structJr_1_1Piece.html">Piece</a> &amp;&#160;</td>
          <td class="paramname"><em>piece</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>from</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Génère les déplacements "bruts" possibles pour une pièce à une case donnée. </p>
<p>Génère la liste des mouvements "bruts" (non filtrés par les règles d'échec) pour une pièce donnée. Cette fonction calcule toutes les cases où une pièce pourrait se déplacer ou capturer, sans prendre en compte si le mouvement mettrait le roi en échec.</p>
<p>Ces mouvements ne tiennent pas compte de la mise en échec du roi ni d'autres règles avancées.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">piece</td><td>La pièce concernée. </td></tr>
    <tr><td class="paramname">from</td><td>La case d'origine (0-63). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vecteur d'indices de cases accessibles.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">piece</td><td>L'objet <a class="el" href="structJr_1_1Piece.html" title="Structure représentant une pièce d&#39;échecs logique (sans aspects graphiques).">Piece</a> (type et couleur) pour laquelle générer les mouvements. </td></tr>
    <tr><td class="paramname">from</td><td>L'index de la case de départ de la pièce. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Un vecteur d'entiers représentant les index des cases cibles possibles. </dd></dl>
<p>Lambda fonction utilitaire pour ajouter une case à la liste des mouvements. Vérifie si la case est dans les limites du plateau et si elle est vide ou occupée par une pièce ennemie. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>La rangée de la case cible. </td></tr>
    <tr><td class="paramname">c</td><td>La colonne de la case cible.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7e13a0213ea6fab80ebbb636bf05e9ff" name="a7e13a0213ea6fab80ebbb636bf05e9ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e13a0213ea6fab80ebbb636bf05e9ff">&#9670;&#160;</a></span>getWhiteTurn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Jr::ChessLogic::getWhiteTurn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtient le tour actuel. </p>
<dl class="section return"><dt>Returns</dt><dd>true si c'est le tour des blancs, false pour les noirs. </dd></dl>

</div>
</div>
<a id="a424e4a7e07f392783456305bfe833052" name="a424e4a7e07f392783456305bfe833052"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a424e4a7e07f392783456305bfe833052">&#9670;&#160;</a></span>initializeBoard()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Jr::ChessLogic::initializeBoard </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise la position de départ du plateau (placement initial des pièces). Réinitialise aussi toutes les variables d'état (roque, promotion, etc). </p>
<p>Initialise les bitboards et les variables d'état du jeu pour une nouvelle partie. Définit la position de départ de toutes les pièces sur le plateau, et réinitialise les drapeaux de tour, de roque, de prise en passant et de promotion. </p>

</div>
</div>
<a id="a22f2ef871ab03cb649074d3fcefb2ff5" name="a22f2ef871ab03cb649074d3fcefb2ff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22f2ef871ab03cb649074d3fcefb2ff5">&#9670;&#160;</a></span>is50MoveRuleDraw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Jr::ChessLogic::is50MoveRuleDraw </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vérifie si la partie est un match nul par la règle des 50 coups sans capture ni mouvement de pion. </p>
<dl class="section return"><dt>Returns</dt><dd>True si c'est un draw par 50 coups, False sinon. </dd></dl>

</div>
</div>
<a id="a174fc9bcebb4078dea570be8ffd8dbb7" name="a174fc9bcebb4078dea570be8ffd8dbb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a174fc9bcebb4078dea570be8ffd8dbb7">&#9670;&#160;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Jr::ChessLogic::isEmpty </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sq</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vérifie si la case spécifiée est vide. </p>
<p>Vérifie si une case spécifique est vide. Utilise le bitboard <code>bitboardPieces</code> qui représente toutes les cases occupées.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sq</td><td>Index de la case (0-63) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true si la case est vide, false sinon.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sq</td><td>L'index de la case (0-63). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True si la case est vide, False sinon. </dd></dl>

</div>
</div>
<a id="a6896304132806f888290d52dcd3048bd" name="a6896304132806f888290d52dcd3048bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6896304132806f888290d52dcd3048bd">&#9670;&#160;</a></span>isEnemy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Jr::ChessLogic::isEnemy </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>whitePiece</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vérifie si la pièce à la case donnée est ennemie par rapport à la couleur spécifiée. </p>
<p>Vérifie si une case contient une pièce ennemie par rapport à une pièce d'une couleur donnée.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sq</td><td>Index de la case (0-63) </td></tr>
    <tr><td class="paramname">whitePiece</td><td>true si la pièce de référence est blanche, false si noire </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true si la pièce sur la case est adverse, false sinon.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sq</td><td>L'index de la case (0-63). </td></tr>
    <tr><td class="paramname">whitePiece</td><td>La couleur de la pièce de référence (True si blanche, False si noire). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True si la case contient une pièce de couleur opposée à <code>whitePiece</code>, False sinon. </dd></dl>

</div>
</div>
<a id="a0d4a612b69f640ce82998c957183c1c9" name="a0d4a612b69f640ce82998c957183c1c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d4a612b69f640ce82998c957183c1c9">&#9670;&#160;</a></span>isInsufficientMaterial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Jr::ChessLogic::isInsufficientMaterial </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vérifie si la partie est un match nul par matériel insuffisant. </p>
<dl class="section return"><dt>Returns</dt><dd>True si c'est un draw par matériel, False sinon. </dd></dl>

</div>
</div>
<a id="ab91c428d04308450340957bf716c8df7" name="ab91c428d04308450340957bf716c8df7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab91c428d04308450340957bf716c8df7">&#9670;&#160;</a></span>isKingInCheck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Jr::ChessLogic::isKingInCheck </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>whiteKing</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indique si le roi de la couleur spécifiée est en échec. </p>
<p>Vérifie si un roi est en échec. Détermine si le roi de la couleur spécifiée est attaqué par une pièce adverse.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">whiteKing</td><td>true pour roi blanc, false pour roi noir. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true si le roi est en échec, false sinon.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">whiteKing</td><td>True pour vérifier le roi blanc, False pour le roi noir. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True si le roi est en échec, False sinon. </dd></dl>

</div>
</div>
<a id="a80417575ab23dd5d822beb75694f5ddc" name="a80417575ab23dd5d822beb75694f5ddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80417575ab23dd5d822beb75694f5ddc">&#9670;&#160;</a></span>isPromotionPending()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Jr::ChessLogic::isPromotionPending </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indique si une promotion est en attente de choix. </p>
<dl class="section return"><dt>Returns</dt><dd>true si une promotion est en attente, false sinon. </dd></dl>

</div>
</div>
<a id="a3f992522dea5ba44b99f839356df4f83" name="a3f992522dea5ba44b99f839356df4f83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f992522dea5ba44b99f839356df4f83">&#9670;&#160;</a></span>isStalemate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Jr::ChessLogic::isStalemate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vérifie si la partie est un match nul par pat (stalemate). </p>
<dl class="section return"><dt>Returns</dt><dd>True si c'est un pat, False sinon. </dd></dl>

</div>
</div>
<a id="a9222446b34ffaf4dff45d44c06c57a50" name="a9222446b34ffaf4dff45d44c06c57a50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9222446b34ffaf4dff45d44c06c57a50">&#9670;&#160;</a></span>isThreeFoldRepetitionDraw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Jr::ChessLogic::isThreeFoldRepetitionDraw </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vérifie si la partie est un match nul par répétition de position. </p>
<dl class="section return"><dt>Returns</dt><dd>True si c'est un draw par répétition, False sinon. </dd></dl>

</div>
</div>
<a id="a43b8e42452b85679c562632d278dcfe9" name="a43b8e42452b85679c562632d278dcfe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43b8e42452b85679c562632d278dcfe9">&#9670;&#160;</a></span>isValidMove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Jr::ChessLogic::isValidMove </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vérifie si un mouvement est valide selon les règles du jeu. </p>
<p>Vérifie si un coup est légal avant de l'effectuer. Cette fonction utilise <code>getLegalMoves</code> pour déterminer si la case cible <code>to</code> est une destination valide pour la pièce à <code>from</code>.</p>
<p>Cette méthode valide la légalité complète, y compris la non-mise en échec du roi.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>Case d'origine du mouvement (0-63). </td></tr>
    <tr><td class="paramname">to</td><td>Case de destination (0-63). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true si le mouvement est légal, false sinon.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>L'index de la case de départ. </td></tr>
    <tr><td class="paramname">to</td><td>L'index de la case d'arrivée. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True si le coup est légal, False sinon. </dd></dl>

</div>
</div>
<a id="a5845e6976c588fbc888a02c7d0196076" name="a5845e6976c588fbc888a02c7d0196076"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5845e6976c588fbc888a02c7d0196076">&#9670;&#160;</a></span>makeMove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Jr::ChessLogic::makeMove </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Effectue un coup valide et met à jour l'état du jeu. </p>
<p>Effectue un coup sur le plateau et met à jour l'état du jeu. Avant d'effectuer le coup, il vérifie sa légalité via <code>isValidMove</code>. Gère les captures, la prise en passant, le roque, la promotion des pions et le changement de tour.</p>
<p>Met à jour les bitboards, le tour, les droits au roque, prise en passant, promotion, etc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>Case d'origine (0-63). </td></tr>
    <tr><td class="paramname">to</td><td>Case de destination (0-63). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true si le mouvement a été effectué avec succès, false sinon (ex: coup illégal).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>L'index de la case de départ de la pièce. </td></tr>
    <tr><td class="paramname">to</td><td>L'index de la case d'arrivée de la pièce. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True si le coup a été effectué avec succès, False si le coup n'était pas légal. </dd></dl>

</div>
</div>
<a id="ab15e4171c8645f7da53310f807723014" name="ab15e4171c8645f7da53310f807723014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab15e4171c8645f7da53310f807723014">&#9670;&#160;</a></span>promotePawn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Jr::ChessLogic::promotePawn </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>square</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PieceType&#160;</td>
          <td class="paramname"><em>newType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Effectue la promotion d'un pion à une case donnée vers un nouveau type de pièce. </p>
<p>Gère la promotion d'un pion à une nouvelle pièce choisie par le joueur. Cette fonction est appelée après qu'un pion ait atteint la dernière rangée et que le joueur ait sélectionné le type de pièce désiré.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">square</td><td>Case où la promotion doit avoir lieu (0-63). </td></tr>
    <tr><td class="paramname">newType</td><td>Type de pièce choisie pour la promotion (ex: Dame, Tour, Fou, Cavalier).</td></tr>
    <tr><td class="paramname">square</td><td>La case où le pion est promu. </td></tr>
    <tr><td class="paramname">newType</td><td>Le type de pièce vers laquelle le pion doit être promu (Queen, Rook, Bishop, Knight). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b57939b3aad263be45a3d3ce2d77867" name="a5b57939b3aad263be45a3d3ce2d77867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b57939b3aad263be45a3d3ce2d77867">&#9670;&#160;</a></span>wouldBeInCheck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Jr::ChessLogic::wouldBeInCheck </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>whiteKing</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vérifie si un coup hypothétique mettrait le roi en échec. </p>
<p>Simule un coup pour vérifier si le roi serait en échec après ce coup. Crée une copie temporaire de l'état du plateau, effectue le coup simulé dessus, puis vérifie si le roi de la couleur spécifiée est en échec dans cet état simulé. L'état original du jeu n'est pas modifié.</p>
<p>Utilisé pour valider la légalité des coups.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>Case d'origine (0-63). </td></tr>
    <tr><td class="paramname">to</td><td>Case de destination (0-63). </td></tr>
    <tr><td class="paramname">whiteKing</td><td>Couleur du roi à protéger (true = blanc). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true si le roi serait en échec après ce coup, false sinon.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>L'index de la case de départ de la pièce. </td></tr>
    <tr><td class="paramname">to</td><td>L'index de la case d'arrivée de la pièce. </td></tr>
    <tr><td class="paramname">whiteKing</td><td>La couleur du roi dont on vérifie l'échec (True si blanc, False si noir). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True si le roi serait en échec après le coup simulé, False sinon. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/<a class="el" href="ChessLogic_8hpp_source.html">ChessLogic.hpp</a></li>
<li>source/<b>ChessLogic.cpp</b></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>Jr</b></li><li class="navelem"><a class="el" href="classJr_1_1ChessLogic.html">ChessLogic</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
